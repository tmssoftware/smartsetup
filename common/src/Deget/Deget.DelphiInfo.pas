unit Deget.DelphiInfo;

interface

{$IFDEF MSWINDOWS}

uses
  Windows, TypInfo,
  Deget.IDEInfo,
  Deget.CoreTypes,
  Classes,
  Deget.IDETypes;

// this unit contains useful tools to retrieve and update information about Delphi IDE, including platforms:
// register package, retrieve search path, update search path, retrieve root dir, lib dir, etc.

type
  TDelphiIDEInfo = class;

  TDelphiIDEPlatformInfo = class(TInterfacedObject, IDelphiPlatformInfo)
  public
    const
      IDEPathNames: array[TDelphiPathType] of string = (
         'Delphi Search Path',
         'Delphi Browsing Path',
         'Debug DCU Path',
         'C++ Library Path',
         'C++ Include Path',
         'C++ Browsing Path',
         'C++ Library Path (Clang 32)',
         'C++ Include Path (Clang 32)',
         'C++ Browsing Path (Clang 32)'
        );
      IDEPathIdents: array[TDelphiPathType] of string = (
         'Search Path',
         'Browsing Path',
         'Debug DCU Path',
         'LibraryPath',
         'IncludePath',
         'BrowsingPath',
         'LibraryPath_Clang32',
         'IncludePath_Clang32',
         'BrowsingPath_Clang32'
        );
      CppPathTypes = [ptCppLibraryPath, ptCppIncludePath, ptCppBrowsingPath,
      ptCppClang32LibraryPath, ptCppClang32IncludePath, ptCppClang32BrowsingPath];
  strict private
    FIDE: TDelphiIDEInfo;
    FPlatType: TPlatform;
//    FDefaultBplOutputFolder: string;
    function IDEPathsRegistryKey(PathType: TDelphiPathType): string;
//    function RetrieveBplOutputDirUsingMSBuild(APlat: TPlatform): string;
  private
    function GetIDEName: TIDEName;
  strict protected

    property IDEName: TIDEName read GetIDEName;
    property IDE: TDelphiIDEInfo read FIDE;
  public
    { IDelphiPlatformInfo method }
    function PlatType: TPlatform;
    function IDEInfo: IDelphiIDEInfo;
    procedure AddIDEPath(PathType: TDelphiPathType; const PathsToAdd: string);
    procedure RemoveIDEPath(PathType: TDelphiPathType; const PathsToRemove: string);
    function GetIDEPath(PathType: TDelphiPathType): string;
    // Updates the contents of the specified path. Warnings, this will replace the whole content
    // if you want just to add a new directory to the path (collection of paths) use AddIDEPath
    procedure SetIDEPath(PathType: TDelphiPathType; const Value: string);
    function PlatformMacroValue: string;
    function ProductVersionMacroValue: string;
    function BinaryPackageName(const BaseName: string; AddLibSuffix: Boolean; const IsExe: boolean; const NonStandardSuffixes: TLibSuffixes): string;
  public
    constructor Create(AIDE: TDelphiIDEInfo; APlatType: TPlatform);

    // Returns Delphi lib directory. Note: this is NOT the root lib dir, but instead
    // the directory which contains library files (dcp/dcu, etc.), for the specified platform,
    // using release config. Can be used for manual compilation
    // Example: "C:\Program Files (x86)\Embarcadero\Studio\15.0\Lib\win32\release"
    function LibDir: string;
    // Same as LibDir but using Debug binaries (they are different when compiling for iOS/Android
    function DebugLibDir: string;

    function RedistDir: string;

    // Returns the name of MSBuild platform Build used to build for that platform
    function BuildName: string;

    // The "id" of the platform, used in several places like $(Platform) macro, output directories, etc..
    // In XE8 "iOSDevice" was renamed to "iOSDevice32".
    function PlatformId: string;

    // indicates if the specified platform/delphi version supports CBuilder
    function SupportsCBuilder: boolean;

    // returns the file extensions for binary files generated by a package compile
    // if IncludeCBuilder is true it also includes C++Builder output
    function BinaryExtensions(IncludeCBuilder: boolean): TArray<string>;

    function HasStaticLibrary: boolean;

    // returns true if the specified platform generates .bpi file for the package file
    function HasBpiFile: boolean;

    // returns true if the specified platform generates a binary package file (bpl/dylib for example).
    function GeneratesPackage: boolean;

//    // Retrieves the default bpl output folder for the specified delphi version/platform
//    // This function is useful to know where the BPL folder is located if the BplOutputDir compilation parameter is empty
//    // It's also useful during the install to create a sym link in that folder so that product bpl if found by Windows,
//    // since the DefaultBplOutputFolder is added to Windows System Path environment variable by Delphi
//    function DefaultBplOutputFolder: string;
  end;

  TDelphiIDEInfo = class(TInterfacedObject, IDelphiIDEInfo)
  strict private
    FIDEName: TIDEName;
    FRootDir: string;
    FHasCustomCompilerPaths: boolean;
    FRootRegistryKey: string;
    function IsAndroidSDKInstalled: boolean;
    function IsAndroid64SDKInstalled: boolean;
    function IsSdkInRegistry(const SdkRegName: string): Boolean;
    function GetEnvVarOverride(const VarName: string): string;
    procedure SetEnvVarOverride(const VarName, Value: string);
  private
    function InternalBaseKey(const SubKey: string): string;
  public
    function BaseKey64(const SubKey: string;
      const IDEPlatform: TPlatform): string;
    function BaseKey(const SubKey: string = ''): string;
  public
    { IDelphiIDEInfo method }
    function IDEName: TIDEName;
    function GetPlatform(PlatType: TPlatform): IDelphiPlatformInfo;
    procedure RegisterPackage(const BinaryFileName: string; const IDEPlatform: TPlatform; const Description: string = '');
    procedure UnregisterPackage(const BinaryFileName: string; const IDEPlatform: TPlatform);
  public
    constructor Create(const AIDEName: TIDEName; const ARegistryName: string = ''; const ACompilerPath: string = '');
    destructor Destroy; override;
    function IsIDERunning: boolean;
    function IsDelphiInstalled: boolean;
    function IsCBuilderInstalled: boolean;
    function IsPlatformInstalled(APlat: TPlatform): Boolean;
    procedure ForceIDEUpdate;

    function GetPathOverride: string;
    procedure AddFolderToPathOverride(const PathsToAdd: string; AddToBeginning: Boolean = True);
    procedure RemoveFolderFromPathOverride(const PathsToRemove: string);

    // Returns the location of Delphi Root Directory (install directory)
    // Example: "C:\Program Files (x86)\Embarcadero\Studio\15.0"
    function RootDir: string;

    //True if we aren't reading the compiler paths from the registry.
    function HasCustomCompilerPaths: boolean;

    // Returns the full file name of rsvars.bat file
    // Example: "C:\Program Files (x86)\Embarcadero\Studio\15.0\bin\rsvars.bat"
    function RsvarsFile: string;

    // Returns the full file name of dcc32.exe file
    // Example: "C:\Program Files (x86)\Embarcadero\Studio\15.0\bin\dcc32.exe"
    function Dcc32File: string;

    // Returns the full file name of Brcc32.exe file
    function Brcc32File: string;

    // Returns the full file name of Bds.exe file
    function BdsFile: string;

    // Location of resinator.exe
    function ResinatorFile: string;


    // Returns Delphi bin directory
    // Example: "C:\Program Files (x86)\Embarcadero\Studio\15.0\bin"
    function BinDir: string;

    function Bin64Dir: string;

    // Retrieves the BDSCOMMONDIR for the specified IDE
    // If user has overriden it in Delphi IDE, it will return the overriden value (from registry)
    // otherwise it will return the default value, from the rsvars.bat file
    function BdsCommonDir: string;

    function GetEnvVarOverrides: TArray<TEnvVar>;

//    property Plats[Plat: TDelphiPlatformType]: TDelphiIDEPlatformInfo read GetPlats; default;
  end;

function Expand(const S: string; IDEName: TIDEName): string; overload;
//function Expand(const S: string; Version: TDelphiVersion; Plat: TDelphiPlatformType; const BaseDir: string): string; overload;

{$ENDIF}

implementation

{$IFDEF MSWINDOWS}

uses
  TlHelp32, Registry, System.Types, System.SysUtils, System.IOUtils, System.StrUtils,
  Deget.Registry, Deget.IDEUtils, SyncObjs;

function Expand(const S: string; IDEName: TIDEName): string;
begin
  Result := S;
  Result := StringReplace(Result, '{#delphisuffix}', DelphiSuffixes[IDEName], [rfReplaceAll, rfIgnoreCase]);
end;

//function Expand(const S: string; Version: TDelphiVersion; Plat: TDelphiPlatformType; const BaseDir: string): string; overload;
//begin
//  Result := S;
//  Result := Expand(Result, Version);
////  Result := StringReplace(Result, '{#platform}', _Delphi[Version][Plat].BuildName, [rfReplaceAll, rfIgnoreCase]);
//  Result := StringReplace(Result, '{#basedir}', BaseDir, [rfReplaceAll, rfIgnoreCase]);
//end;

function IsModuleLoaded(Name: PChar): boolean;
var
  ContinueLoop: BOOL;
  FSnapshotHandle: THandle;
  FProcessEntry32: TProcessEntry32;
begin
  FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
  ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32);
  Result := False;
  while Integer(ContinueLoop) <> 0 do
  begin
    if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
      UpperCase(Name)) or (UpperCase(FProcessEntry32.szExeFile) =
      UpperCase(Name))) then
    begin
      Result := True;
    end;
    ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
  end;
  CloseHandle(FSnapshotHandle);
end;

{ TDelphiIDEInfo }

procedure TDelphiIDEInfo.AddFolderToPathOverride(const PathsToAdd: string; AddToBeginning: Boolean = True);
begin
  var Lock := TMutex.Create(nil, false, Mutex_PathOverride);
  try
    Lock.Acquire;
    try
      SetEnvVarOverride('PATH', AddPaths(GetEnvVarOverride('PATH'), PathsToAdd, AddToBeginning));
    finally
      Lock.Release;
    end;
  finally
    Lock.Free;
  end;
end;

function TDelphiIDEInfo.InternalBaseKey(const SubKey: string): string;
begin
//  Logger.Note(Format('Building IDE base registry key with subkey "%s', [SubKey]));
  Result := FRootRegistryKey;
//  Logger.Note(Format('Base key value: %s', [Result]));

  if SubKey <> '' then
  begin
    if SubKey[1] <> '\' then
      Result := Result + '\';
    Result := Result + SubKey;
//    Logger.Note(Format('Base key with subkey value: %s', [Result]));
  end;
end;


function TDelphiIDEInfo.BaseKey64(const SubKey: string; const IDEPlatform: TPlatform): string;
begin
  Result := InternalBaseKey(SubKey);
  case IDEPlatform of
    win32intel: ;

    win64intel,
    win64Xintel: Result := Result + ' x64';
    else raise Exception.Create('Error: Delphi IDE must be 32 or 64 bit.');
  end;
end;

function TDelphiIDEInfo.BaseKey(const SubKey: string): string;
begin
  if   (SubKey = 'Known IDE Packages')
    or (SubKey = 'Known Packages')
    or (SubKey = 'Experts')
    or (SubKey = 'Disabled Packages')
    or (SubKey = 'Disabled IDE Packages')
    then
    begin
      //Call BaseKey64 for this entries.
      raise Exception.Create('Internal error. Can''t change the key ''' + SubKey + ''' without knowing the IDE bitness.');
    end;

  Result := InternalBaseKey(SubKey);
end;

function TDelphiIDEInfo.BdsCommonDir: string;
var
  RSVarsContent: string;
  P: integer;
begin
//  Logger.Note('Retrieving BDS Common Dir');

  // Check if it was overriden in registry
  if not RegQueryStringValue(BaseKey('Environment Variables'), 'BDSCOMMONDIR', Result) then
  begin
    {Calling command line rsvars.bat worked on windows 7 but not on xp.
     So let's do a "workaround" approach which is just "parsing" the rsvars.bat}
    RSVarsContent := TFile.ReadAllText(RSVarsFile);
    P := Pos('BDSCOMMONDIR=', Uppercase(RSVarsContent));
    if P = 0 then
      raise Exception.Create('Could not find BDSCOMMONDIR is rsvars.bat file.');
    RSVarsContent := Copy(RSVarsContent, P + Length('BDSCOMMONDIR='), MaxInt);
    P := Pos(#13, RSVarsContent);
    if P > 0 then
      RSVarsContent := Copy(RSVarsContent, 1, P - 1);
    P := Pos(#10, RSVarsContent);
    if P > 0 then
      RSVarsContent := Copy(RSVarsContent, 1, P - 1);
    Result := RSVarsContent;
  end;
//  Logger.Trace(Format('BDS Common Dir retrieved: %s', [Result]));
end;

function TDelphiIDEInfo.BinDir: string;
begin
  Result := TPath.Combine(RootDir, 'bin');
end;

function TDelphiIDEInfo.Bin64Dir: string;
begin
  Result := TPath.Combine(RootDir, 'bin64');
end;

constructor TDelphiIDEInfo.Create(const AIDEName: TIDEName; const ARegistryName: string = ''; const ACompilerPath: string = '');
begin
  FIDEName := AIDEName;
  FRootRegistryKey := DelphiRegistryRoot[Self.IDEName];
  if ARegistryName <> '' then
  begin
    FRootRegistryKey := StringReplace(FRootRegistryKey, 'Delphi', ARegistryName, []);
    FRootRegistryKey := StringReplace(FRootRegistryKey, 'BDS', ARegistryName, []);
  end;

  FHasCustomCompilerPaths := ACompilerPath <> '';
  if FHasCustomCompilerPaths then
    FRootDir := ACompilerPath
  else
    RegQueryStringValue(BaseKey, 'rootdir', FRootDir);

  FRootDir := ExcludeTrailingPathDelimiter(FRootDir);
end;

function TDelphiIDEInfo.Dcc32File: string;
begin
  Result := TPath.Combine(BinDir, 'dcc32.exe');
end;

function TDelphiIDEInfo.Brcc32File: string;
begin
  Result := TPath.Combine(BinDir, 'brcc32.exe');
end;

function TDelphiIDEInfo.BdsFile: string;
begin
  Result := TPath.Combine(BinDir, 'bds.exe');
end;

function TDelphiIDEInfo.ResinatorFile: string;
begin
  Result := TPath.Combine(Bin64Dir, 'resinator.exe');
end;

function TDelphiIDEInfo.IDEName: TIDEName;
begin
  Result := FIDEName;
end;

destructor TDelphiIDEInfo.Destroy;
begin
  inherited;
end;

procedure TDelphiIDEInfo.ForceIDEUpdate;
begin
//  Logger.Note('Forcing IDE Update in registry');
  case IDEName of
    delphi7: ;  // Delphi 7 doesn't have that option
  else
    //Shouldn't require a mutex, as we aren't reading the key.
    RegWriteString(HKEY_CURRENT_USER, BaseKey('\Globals'), 'ForceEnvOptionsUpdate', '1');
  end;
end;

function TDelphiIDEInfo.GetEnvVarOverride(const VarName: string): string;
begin
  RegReadString(HKEY_CURRENT_USER, BaseKey('\Environment Variables'), VarName, Result);
end;
function TDelphiIDEInfo.GetEnvVarOverrides: TArray<TEnvVar>;
var
  R: TRegistry;
begin
  R := TRegistry.Create;
  try
    R.RootKey := HKEY_CURRENT_USER;
    var Ok := R.OpenKeyReadOnly(BaseKey('\Environment Variables'));
    if Ok then
    begin
      var Values := TStringList.Create;
      try
        R.GetValueNames(Values);
        SetLength(Result, Values.Count);
        for var i := 0 to Values.Count - 1 do
        begin
          Result[i].Name := Values[i];
          Result[i].Value := R.ReadString(Values[i]);
        end;
      finally
        Values.Free;
      end;
    end
    else
      Result := nil;
  finally
    R.Free;
  end;

end;

function TDelphiIDEInfo.GetPathOverride: string;
begin
  Result := GetEnvVarOverride('PATH');
end;

function TDelphiIDEInfo.GetPlatform(PlatType: TPlatform): IDelphiPlatformInfo;
begin
  Result := TDelphiIDEPlatformInfo.Create(Self, PlatType);
end;

//function TDelphiIDEInfo.GetPlats(Plat: TDelphiPlatformType): TDelphiIDEPlatformInfo;
//begin
//  Result := FPlats[Plat];
//end;

function TDelphiIDEInfo.IsAndroid64SDKInstalled: boolean;
var
  DefaultAndroid: string;
  SDKZipAlignPath, SDKAdbPath: string;
begin
  Result := false;
  if RegReadString(HKEY_CURRENT_USER, BaseKey('\PlatformSDKs'), 'Default_Android64', DefaultAndroid) then
    if (DefaultAndroid <> '') then
    begin
      DefaultAndroid := BaseKey('\PlatformSDKs\' + DefaultAndroid);
      if IDEName >= TIDEName.delphi12 then
      begin
        if RegReadString(HKEY_CURRENT_USER, DefaultAndroid, 'SDKAdbPath', SDKAdbPath) then
        begin
          Result := TFile.Exists(SDKAdbPath);
        end;
      end
      else
      begin
        if RegReadString(HKEY_CURRENT_USER, DefaultAndroid, 'SDKZipAlignPath', SDKZipAlignPath)
          and RegReadString(HKEY_CURRENT_USER, DefaultAndroid, 'SDKAdbPath', SDKAdbPath) then
        begin
          Result := TFile.Exists(SDKZipAlignPath) and TFile.Exists(SDKAdbPath);
        end;
      end;
    end;
end;

function TDelphiIDEInfo.IsAndroidSDKInstalled: boolean;
var
  DefaultAndroid: string;
  SDKZipAlignPath, SDKAdbPath: string;
begin
  Result := false;
  if RegReadString(HKEY_CURRENT_USER, BaseKey('\PlatformSDKs'), 'Default_Android', DefaultAndroid) then
    if (DefaultAndroid <> '') then
    begin
      DefaultAndroid := BaseKey('\PlatformSDKs\' + DefaultAndroid);
      if RegReadString(HKEY_CURRENT_USER, DefaultAndroid, 'SDKZipAlignPath', SDKZipAlignPath)
        and RegReadString(HKEY_CURRENT_USER, DefaultAndroid, 'SDKAdbPath', SDKAdbPath) then
      begin
        Result := TFile.Exists(SDKZipAlignPath) and TFile.Exists(SDKAdbPath);
      end;
    end;
end;

function TDelphiIDEInfo.IsSdkInRegistry(const SdkRegName: string): boolean;
var
  SdkKey: string;
begin
  Result := false;
  if RegReadString(HKEY_CURRENT_USER, BaseKey('\PlatformSDKs'), SdkRegName, SdkKey) then
    if (SdkKey <> '') then
    begin
      SdkKey := BaseKey('\PlatformSDKs\' + SdkKey);
      Result := RegValueExists(HKEY_CURRENT_USER, SdkKey, 'SystemRoot');
    end;
end;

function TDelphiIDEInfo.IsPlatformInstalled(
  APlat: TPlatform): Boolean;
begin
  case APlat of
    iOSSimulator:
      Result := IsSdkInRegistry('Default_iOSSimulator');
    iOSDevice32:
      Result := IsSdkInRegistry('Default_iOSDevice32');
    Android32:
      Result := IsAndroidSDKInstalled;
    iOSDevice64:
      Result := IsSdkInRegistry('Default_iOSDevice64');
    Linux64:
      Result := IsSdkInRegistry('Default_Linux64');
    macOS64Intel:
      Result := IsSdkInRegistry('Default_OSX64');
    macOS32Intel:
      Result := IsSdkInRegistry('Default_OSX32');
    Android64:
      Result := IsAndroid64SDKInstalled;
    macOS64Arm:
      Result := IsSdkInRegistry('Default_OSXARM64');
    iossimulator64arm:
      Result := IsSdkInRegistry('Default_iOSSimARM64');
  else
    Result := True;
  end;
end;

function TDelphiIDEInfo.IsCBuilderInstalled: boolean;
begin
//  Logger.Note('Checking if C++Builder is installed');
  Case IDEName of
    delphi7:
      result := false;
    delphi2007..delphixe5:
      result := RegValueExists(HKEY_LOCAL_MACHINE, BaseKey('\Personalities'), 'BCB');
  else
    Result := RegValueExists(HKEY_LOCAL_MACHINE, BaseKey('\Personalities'), 'BCB');
  end;
//  Logger.Note(Format('Result: %s', [BoolToStr(Result, true)]));
end;

function TDelphiIDEInfo.IsDelphiInstalled: boolean;
begin
//  Logger.Note('Checking if Delphi is installed');
  Case IDEName of
    delphi7:
      result := RegKeyExists(HKEY_LOCAL_MACHINE, BaseKey);
    delphi2007..delphixe5:
      result := RegValueExists(HKEY_LOCAL_MACHINE, BaseKey('\Personalities'), 'Delphi.Win32');
  else
    Result := RegValueExists(HKEY_LOCAL_MACHINE, BaseKey('\Personalities'), 'Delphi.Win32');
  end;
//  Logger.Note(Format('Result: %s', [BoolToStr(Result, true)]));
end;

function TDelphiIDEInfo.IsIDERunning: boolean;
begin
//  Logger.Note('Checking if IDE is running');
  case IDEName of
    delphi7: result := IsModuleLoaded('delphi32.exe')
  else
    Result := IsModuleLoaded('bds.exe');
  end;
//  Logger.Note(Format('Result: %s', [BoolToStr(Result, true)]));
end;

procedure TDelphiIDEInfo.RegisterPackage(const BinaryFileName: string; const IDEPlatform: TPlatform; const Description: string = '');
var
  LDescription: string;
begin
//  Logger.Note(Format('Registering package %s - %s', [BinaryFileName, Description]));
  if BinaryFileName <> '' then
  begin
    if Description = '' then
      LDescription := '(Untitled)'
    else
      LDescription := Description;
    //Shouldn't require a mutex, as we aren't reading the key.

    if not TFile.Exists(BinaryFileName) then raise Exception.Create('Internal error. Trying to register package ' + BinaryFileName + ' that doesn''t exist');

    //CanCreate is false, so if "Known Packages x64" doesn't exist we don't create it. Might happen for Delphi 12.0, or if we didn't install Win64 IDE.
    RegWriteString(HKEY_CURRENT_USER, BaseKey64('Known Packages', IDEPlatform), BinaryFileName, LDescription, false);
    RegDeleteValue(HKEY_CURRENT_USER, BaseKey64('Disabled Packages', IDEPlatform), BinaryFileName);

  end;
end;

procedure TDelphiIDEInfo.RemoveFolderFromPathOverride(const PathsToRemove: string);
begin
  var Lock := TMutex.Create(nil, false, Mutex_PathOverride);
  try
    Lock.Acquire;
    try
      SetEnvVarOverride('PATH', RemovePaths(GetEnvVarOverride('PATH'), PathsToRemove));
    finally
      Lock.Release;
    end;
  finally
    Lock.Free;
  end;
end;

function TDelphiIDEInfo.RootDir: string;
begin
  Result := FRootDir;
end;

function TDelphiIDEInfo.HasCustomCompilerPaths: Boolean;
begin
  Result := FHasCustomCompilerPaths;
end;

function TDelphiIDEInfo.RsvarsFile: string;
begin
  Result := TPath.Combine(BinDir, 'rsvars.bat');
end;

procedure TDelphiIDEInfo.SetEnvVarOverride(const VarName, Value: string);
begin
  var Key := BaseKey('\Environment Variables');
  if RegKeyExists(HKEY_CURRENT_USER, Key) then
    RegWriteString(HKEY_CURRENT_USER, Key, VarName, Value);
end;

procedure TDelphiIDEInfo.UnregisterPackage(const BinaryFileName: string; const IDEPlatform: TPlatform);
begin
//  Logger.Note(Format('Unregistering package %s', [FileName]));
  if BinaryFileName <> '' then
    //Shouldn't require a mutex, as we aren't reading the key.
    RegDeleteValue(HKEY_CURRENT_USER, BaseKey64('Known Packages', IDEPlatform), BinaryFileName);
end;

{ TDelphiIDEPlatformInfo }

procedure TDelphiIDEPlatformInfo.AddIDEPath(PathType: TDelphiPathType; const PathsToAdd: string);
begin
  var Lock := TMutex.Create(nil, false, Mutex_IDEPath);
  try
    Lock.Acquire;
    try
      SetIDEPath(PathType, AddPaths(GetIDEPath(PathType), PathsToAdd));
    finally
      Lock.Release;
    end;
  finally
    Lock.Free;
  end;
end;

function TDelphiIDEPlatformInfo.BinaryExtensions(
  IncludeCBuilder: boolean): TArray<string>;
begin
  Result := ['*.dcu'];
  if PlatType in [iOSDevice32, Android32, Android64, iOSDevice64, Linux64] then
    Result := Result + ['*.o'];
  if IncludeCBuilder and SupportsCBuilder then
    Result := Result + ['*.hpp'];
end;

function TDelphiIDEPlatformInfo.BinaryPackageName(const BaseName: string; AddLibSuffix: Boolean; const IsExe: boolean; const NonStandardSuffixes: TLibSuffixes): string;
var
  Suffix: string;
begin
  if AddLibSuffix then
  begin
    if NonStandardSuffixes[IDEName] = '' then Suffix := PackageSuffixes[IDEName] else Suffix := NonStandardSuffixes[IDEName];
  end
  else
  begin
    Suffix := '';
  end;

  case PlatType of
    Win32Intel:
    begin
      if IsExe then exit(Format('%s.exe', [BaseName]));
      Result := Format('%s%s.bpl', [BaseName, Suffix]);
    end;
    Win64Intel,
    Win64XIntel:
    begin
      if IsExe then exit(Format('%s.exe', [BaseName]));
      Result := Format('%s%s.bpl', [BaseName, Suffix]);
    end;
    macOS32Intel, macOS64Intel:
      Result := Format('bpl%s%s.dylib', [BaseName, Suffix]);
    Linux64:
      Result := Format('bpl%s%s.so', [BaseName, Suffix]);
  else
    Result := ''; // other platforms do not generate packages
  end;

  if IsExe then exit(Format('%s', [BaseName]));

end;

function TDelphiIDEPlatformInfo.BuildName: string;
begin
  Result := PlatformId; // for now, it's the same
end;

constructor TDelphiIDEPlatformInfo.Create(AIDE: TDelphiIDEInfo; APlatType: TPlatform);
begin
  FIDE := AIDE;
  FPlatType := APlatType;
end;

function TDelphiIDEPlatformInfo.DebugLibDir: string;
begin
  Result := TPath.Combine(IDE.RootDir, 'lib');
  if IDEName >= delphixe then
    Result := TPath.Combine(Result, PlatformId + '\debug')
  else
    Result := TPath.Combine(Result, 'debug')
end;

//function TDelphiIDEPlatformInfo.DefaultBplOutputFolder: string;
//begin
//  if FDefaultBplOutputFolder <> '' then
//    Exit(FDefaultBplOutputFolder);
//
//  Logger.Trace(Format('Retrieving Default Bpl Output Folder for %s, %s', [DelphiNames[IDEName], PlatformId]));
//
//  case IDEName of
//    delphi7:
//      // Delphi 7 is a different beast, so we will consider bpl output folder is just
//      // the default one, hard coded
//      FDefaultBplOutputFolder := TPath.Combine(IDE.RootDir, 'Projects\Bpl');
//
//    delphi2007..delphi2010:
//      // until d2010 the msbuild project way is not working. So let's just get the bdscommondir directly
//      // we don't have platforms anyway
//      FDefaultBplOutputFolder := TPath.Combine(IDE.BdsCommonDir, 'Bpl');
//  else
//    FDefaultBplOutputFolder := RetrieveBplOutputDirUsingMSBuild(PlatType);
//    if (FDefaultBplOutputFolder = '') and (PlatType <> Win32Intel) then
//    begin
//      // In Delphi Seattle, it's not working for non-win32 platforms, so let's do a workaround
//      FDefaultBplOutputFolder := RetrieveBplOutputDirUsingMSBuild(Win32Intel);
//      if FDefaultBplOutputFolder <> ''  then
//        FDefaultBplOutputFolder := TPath.Combine(FDefaultBplOutputFolder, BuildName);
//    end;
//    if FDefaultBplOutputFolder = '' then
//    begin
//      var TempFolder := TPath.Combine(IDE.BdsCommonDir, 'Bpl');
//      if PlatType <> Win32Intel then
//        TempFolder := TPath.Combine(TempFolder, BuildName);
//      if TDirectory.Exists(TempFolder) then
//        FDefaultBplOutputFolder := TempFolder
//      else
//      begin
//        Logger.Error('Could not retrieve bpl default output directory');
//        raise Exception.Create('Could not retrieve Bpl Default Output Directory');
//      end;
//    end;
//  end;
//  Result := FDefaultBplOutputFolder;
//end;

function TDelphiIDEPlatformInfo.GeneratesPackage: boolean;
begin
  Result := PlatType in [Win32Intel, Win64Intel, Win64XIntel, macOS32Intel, macOS64Intel, Linux64];
end;

function TDelphiIDEPlatformInfo.GetIDEName: TIDEName;
begin
  Result := FIDE.IDEName;
end;

function TDelphiIDEPlatformInfo.GetIDEPath(PathType: TDelphiPathType): string;
begin
  if not RegReadString(HKEY_CURRENT_USER, IDEPathsRegistryKey(PathType), IDEPathIdents[PathType], Result) then
    Result := '';
//  Logger.Note(Format('IDE Path %s read. Value: %s', [IDEPathNames[PathType], Result]));
end;

function TDelphiIDEPlatformInfo.HasBpiFile: boolean;
begin
  Result := not (PlatType in [iOSDevice32, iOSDevice64, iOSSimulator, Android32, Android64]);
end;

function TDelphiIDEPlatformInfo.HasStaticLibrary: boolean;
begin
  Result := PlatType <> iOSSimulator;
end;

function TDelphiIDEPlatformInfo.IDEInfo: IDelphiIDEInfo;
begin
//  Result := FIDEInfo;
  Result := FIDE;
end;

function TDelphiIDEPlatformInfo.IDEPathsRegistryKey(PathType: TDelphiPathType): string;
const
  _PlatformRegSubKey: array[TPlatform] of string =
    ('Win32', 'Win64', 'OSX32', 'OSX64', 'OSXARM64', 'iOSSimulator', 'iOSDevice32', 'iOSDevice64',
     'Android32', 'Android64', 'Linux64', 'iOSSimARM64', 'Win64x');

  function PlatSubKey: string;
  begin
    Result := _PlatformRegSubKey[PlatType];
    if (PlatType = iOSDevice32) and (IDEName <= delphixe7) then
      Result := 'iOSDevice';
  end;

  function DelphiLibraryKey: string;
  begin
    case IDEName of
      delphi7..delphixe:
        Result := IDE.BaseKey('\Library');
    else
      // default
      // dxe2..dxe5:
      Result := IDE.BaseKey('\Library\') + PlatSubKey;
    end;
  end;

  function CBuilderLibraryKey: string;
  begin
    case IDEName of
      delphi7..delphi2006:
        Result := 'CppPaths';

      delphi2007..delphixe:
        Result := IDE.BaseKey('C++\Paths');
    else
      // default
      // dxe2..dxe5:
      Result := IDE.BaseKey('C++\Paths\') + PlatSubKey;
    end;
  end;

begin
  if PathType in CppPathTypes then
    Result := CBuilderLibraryKey
  else
    Result := DelphiLibraryKey;
end;

function TDelphiIDEPlatformInfo.LibDir: string;
begin
  Result := TPath.Combine(IDE.RootDir, 'lib');
  if IDEName >= delphixe then
    Result := TPath.Combine(Result, PlatformId + '\release');
end;

function TDelphiIDEPlatformInfo.PlatformId: string;
const
  PlatformNames: array[TPlatform] of string =
    ('Win32', 'Win64', 'OSX32', 'OSX64', 'OSXARM64', 'iOSSimulator', 'iOSDevice32', 'iOSDevice64',
     'Android', 'Android64', 'Linux64', 'iOSSimARM64', 'Win64x');
begin
  Result := PlatformNames[PlatType];
  if (PlatType = TPlatform.iOSDevice32) and (IDEName <= delphixe7) then
    Result := 'iOSDevice';
end;

function TDelphiIDEPlatformInfo.PlatformMacroValue: string;
begin
  Result := PlatformId;
end;

function TDelphiIDEPlatformInfo.ProductVersionMacroValue: string;
begin
  Result := DelphiProductVersion[IDEInfo.IDEName];
end;

function TDelphiIDEPlatformInfo.PlatType: TPlatform;
begin
  Result := FPlatType;
end;

function TDelphiIDEPlatformInfo.RedistDir: string;
begin
  Result := TPath.Combine(IDE.RootDir, 'Redist');
  if PlatType = TPlatform.macos64arm then
    Result := TPath.Combine(Result, 'osx64')
  else
  if PlatType = TPlatform.win64Xintel then
  begin
    //This looks like a bug, maybe later will be fixed.
    //But in 12.1 at least, we don't need redist, but yes the folder below.
    //I think it is a bug, because a "plain" "msbuild TMSVCLUIPackPkg.dproj"
    //from a command line with the correct rsvars will fail. Making it impossible to compile from command line.
    //dcc64.cfg contains the line: -u"c:\program files (x86)\embarcadero\studio\23.0\lib\win64\release"
    //Result := TPath.Combine(Result, 'win64');
    Result := TPath.Combine(IDE.RootDir,'lib', 'win64', 'release');

  end
  else
    Result := TPath.Combine(Result, PlatformId);
end;

procedure TDelphiIDEPlatformInfo.RemoveIDEPath(PathType: TDelphiPathType; const PathsToRemove: string);
begin
  if PathsToRemove = '' then Exit;
  var Lock := TMutex.Create(nil, false, Mutex_IDEPath);
  try
    Lock.Acquire;
    try
      SetIDEPath(PathType, RemovePaths(GetIDEPath(PathType), PathsToRemove));
    finally
      Lock.Release;
    end;
  finally
    Lock.Free;
  end;
end;

//function TDelphiIDEPlatformInfo.RetrieveBplOutputDirUsingMSBuild(
//  APlat: TPlatform): string;
//const
//  BplOutDirBuild =
//    '<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003"> ' +
//    '  <ItemGroup> ' +
//    '  </ItemGroup> ' +
//    ' <Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists(''$(BDS)\Bin\CodeGear.Delphi.Targets'')"/> ' +
//    '  <PropertyGroup> ' +
//    '  <TMS_BplOutput Condition = " ''$(DCC_BplOutput)'' != ''''">$(DCC_BplOutput)</TMS_BplOutput> ' +
//    '  <TMS_BplOutput Condition = " ''$(DCC_BplOutput)'' == ''''">$(CBuilderBPLOutputPath)</TMS_BplOutput> ' +
//    '  </PropertyGroup> ' +
//    '  <Target Name="BPLFOLDER"> ' +
//    '    <Message Text="Folder:{$(TMS_BplOutput)}" /> ' +
//    '  </Target> ' +
//    '</Project> ' +
//    '';
//var
//  BDSCommonDir: string;
//  Batch: string;
//  BatchFile: string;
//  Output: string;
//  Params: string;
//  ProjectFile: string;
//  P1, P2: integer;
//begin
//  Result := '';
//
//  // add parameters to call msbuild project
//  Params := Format('/target:BPLFOLDER /p:Platform=%s', [BuildName]);
//  if RegQueryStringValue(IDE.BaseKey('Environment Variables'), 'BDSCOMMONDIR', BDSCommonDir) then
//    Params := Params + Format(' /p:BDSCOMMONDIR="%s"', [BdsCommonDir]);
////    Params := Params + ' /verbosity:diag';
//
//  // create batch file and compile
//  Batch := Format(
//    'call "%s" '#13#10 +
//    'cd /D %%FrameworkDir%% '#13#10 +
//    'msbuild.exe %%1 %s',
//    [IDE.RsvarsFile, Params]
//  );
////  Logger.Note('Batch file built');
////  Logger.Note(Batch);
//  {$MESSAGE WARN 'Use Config.TempDir'}
//  BatchFile := GetTempFileNameExt('.bat');
//  try
//    TFile.WriteAllText(BatchFile, Batch);
//
//    // now create project file
//    {$MESSAGE WARN 'Use Config.TempDir'}
//    ProjectFile := GetTempFileNameExt('.msbuild');
//    try
//      TFile.WriteAllText(ProjectFile, BplOutDirBuild);
//      if not ExecuteCommand(Format('cmd /C call "%s" "%s"', [BatchFile, ProjectFile]), '', Output) then
//        raise Exception.Create('Could not execute command to retrieve BPL output folder');
//      P1 := Pos('Folder:{', Output);
//      P2 := Pos('}', Output, P1);
//      if (P1 > 0) and (P2 > P1 + 1) then
//      begin
//        P1 := P1 + Length('Folder:{');
//        Result := Copy(Output, P1, P2 - P1);
//      end;
//    finally
//      if TFile.Exists(ProjectFile) then
//        TFile.Delete(ProjectFile);
//    end;
//  finally
//    if TFile.Exists(BatchFile) then
//      TFile.Delete(BatchFile);
//  end;
//end;

procedure TDelphiIDEPlatformInfo.SetIDEPath(PathType: TDelphiPathType; const Value: string);
var
  Key: string;
begin
  Key := IDEPathsRegistryKey(PathType);
  if RegKeyExists(HKEY_CURRENT_USER, Key) then
    RegWriteString(HKEY_CURRENT_USER, Key, IDEPathIdents[PathType], Value);
end;

function TDelphiIDEPlatformInfo.SupportsCBuilder: boolean;
begin
  Result := false;
  if IDEName > delphi7 then
  begin
    case PlatType of
      Win32Intel: Result := true;
      Win64Intel: Result := IDEName >= delphixe3;
      macOS32Intel: Result := IDEName >= delphixe3;
      iOSSimulator: Result := IDEName >= delphixe3;
      iOSDevice32: Result := IDEName >= delphixe3;
      Android32: Result := IDEName >= delphixe3;
      Android64: Result := False;
      iOSDevice64: Result := IDEName > delphixe7;
      Linux64: Result := False; //Result := Version > dRio;
      macOS64Intel: Result := False; //Result := Version > dRio;
      macOS64Arm: Result := False; //Result := Version > dRio;
      iossimulator64arm: Result := False;
      Win64xIntel: Result := IDEName >= delphi12
    end;
  end;
end;

{$ENDIF}

end.
